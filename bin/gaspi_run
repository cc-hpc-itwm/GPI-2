#!/bin/sh

# Copyright (c) Fraunhofer ITWM - Carsten Lojewski <lojewski@itwm.fhg.de>, 2013

# This file is part of GPI-2.

# GPI-2 is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# version 3 as published by the Free Software Foundation.

# GPI-2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with GPI-2. If not, see <http://www.gnu.org/licenses/>.

SET_NUMA=0
MFILE=""
MASTER_PRG=""
PRG=""
KPRG=""
PRGNAME=""
TYP=GASPI_MASTER
MAX_NUMA_NODES=1
HAS_NUMA=0
HN=`/bin/hostname`
TMP_PATTERN=".gpi2.XXXXXXXX"
TMP_MFILE=$(TMPDIR=. mktemp ${TMP_PATTERN})
UNIQ_MFILE=$(TMPDIR=. mktemp ${TMP_PATTERN})
RUN_PATTERN=".gaspi_run.XXXXXXXX"
RUN_FILE=$(TMPDIR=. mktemp ${RUN_PATTERN})
ORIG_MFILE=""
NNODES=0
DEBUG=0

remove_temp_file()
{
    rm -f $TMP_MFILE
    rm -f $UNIQ_MFILE
    rm -f $RUN_FILE
}

#helper functions
usage()
{
    echo
    echo "Usage: gaspi_run -m <machinefile> [OPTIONS] <path GASPI program>"
    echo
    echo "Available options:"
    echo "  -b <binary file> Use a different binary for first node (master)."
    echo "  -N               Enable NUMA for processes on same node."
    echo "  -n <procs>       Start as many <procs> from machine file."
    echo "  -d               Run with GDB (debugger) on master node."
    echo "  -h               This help."
    echo
    remove_temp_file
}

clean_exit()
{
#assumes the clean-up script is in the same directory as gaspi_run
    BASEDIR=`dirname $0`
    $BASEDIR/gaspi_cleanup -m $UNIQ_MFILE

    remove_temp_file
}

print_error_exit()
{
    echo
    echo $1
    echo
    remove_temp_file
    exit 1
}

validate_machinefile()
{
    #empty
    if [ ! -s $MFILE ]; then
	echo "Empty machine file ($1)"
	exit 1
    fi

    #create tmp_file
    if [ -r $TMP_MFILE ]; then
	rm -f $TMP_MFILE
    fi
    if [ `touch $TMP_MFILE 2> /dev/null; echo "$?"` -eq 0 ]; then
	chmod 777 $TMP_MFILE
    else
	print_error_exit "User permissions failure: $PWD is not writable"
    fi


    ncount=0
    while read LINE
    do
	args=`echo $LINE | gawk '{print NF}'`
	i=`echo $LINE | gawk '{print $1}'   `
	if [ "$i" != "" ]; then
     	    ping -c 1 $i > /dev/null 2>&1
     	    if [ $? != 0 ]; then
     		print_error_exit "Host not reachable ($i)"
     	    fi

	    ncount=$(($ncount+1))
	    if [ $NNODES -lt $ncount ]; then
		break
	    fi
	    echo $i >> $TMP_MFILE
	fi
    done < $MFILE

    ORIG_MFILE=$MFILE
    MFILE=$TMP_MFILE

    uniq $MFILE > $UNIQ_MFILE
       #number of nodes (NNODES) must fit number of hosts
    n=`wc -l $MFILE |gawk '{print $1}'`
    if [ $n -lt $NNODES ]; then
	print_error_exit "Not enough hosts ($n) for required number of nodes (-n $NNODES)"
    fi

}

kill_procs()
{
    echo "Killing GASPI procs..."
    for i in $hlist
    do
	ssh $i killall -s KILL $PRGNAME > /dev/null 2>&1 &
    done
    remove_temp_file
    exit 1
}

#at least we need machinefile and binary
if [ $# -lt 3 ]; then
    usage
    exit 1
fi

#command line parsing
while [ "$1" != "" ]; do
    case $1 in
	-m | --machinefile)
	    shift
 	    if [ -r $1 ]; then
		MFILE=$1
            else
		print_error_exit "Error: Cannot read $1 (-m option) (or file does not exist)"
	    fi
	    ;;
	-N | --NUMA)
	    SET_NUMA=1
	    ;;
	-d | --debug)
	    DEBUG=1
	    ;;
	-h | --help)
	    usage
	    ;;
	-b | --binary)
	    shift
	    if [ -x $1 ]; then
		MASTER_PRG=$1
	    else
		print_error_exit "Error: Cannot find $1 (-b option) (or file is not executable)"
	    fi
	    ;;
	-n | --nodes)
	    shift
	    if [ $1 -gt 1 ]; then
		NNODES=$1
	    else
		print_error_exit "Error: GASPI requires at least 2 nodes"
	    fi
	    ;;
	*) #Sucks! we're taking a small risk here
            if [ -x $1 ]; then
                PRG=$*
		KPRG=$1
		break
            else
                print_error_exit "Error: Cannot execute $1 (or file does not exist)"
            fi
    esac
    shift
done

if [ "$PRG" = "" ]; then
    print_error_exit "No binary file provided. See help (-h option)"
fi

trap kill_procs TERM INT QUIT

#sanity check and settings
if [ $SET_NUMA -eq 1 ]; then
    which numactl > /dev/null
    if [ $? = 0 ]; then
	MAX_NUMA_NODES=`numactl --hardware|grep available|gawk '{print $2}'`
	HAS_NUMA=1
    else
	MAX_NUMA_NODES=1
	HAS_NUMA=0
    fi
else
    MAX_NUMA_NODES=256
fi

#let's rock
#use all host in machines file
if [ $NNODES -eq 0 ]; then
    NNODES=`sed /^$/d $MFILE  |wc -l`
fi

validate_machinefile $MFILE


hlist=`cat $MFILE`
t=0
t0=$(date +%s)
previous=`head -n 1 $MFILE`
ncount=0

#take care of paths
TMP_PRG=`readlink -f "$PRG"`
TMP_KPRG=`readlink -f $KPRG`

PRG=$TMP_PRG
KPRG=$TMP_KPRG

#master binary is the same
if [ "$MASTER_PRG" = "" ]; then
    MASTER_PRG=$PRG
fi

#who's master
master_node=`head -n 1 $MFILE`

while read LINE
do
    i=$LINE

    #ignore blank lines
    if [ "$i" = "" ]; then
	continue;
    fi

    if [ $t -eq 0 ]; then
     	TYP=GASPI_MASTER
     	t=$(($t+1))
     	continue
    else
     	TYP=GASPI_WORKER
    fi

    if [ "$i" = "$previous" ]; then
	j=$(($j+1))
	if [ $j -eq $MAX_NUMA_NODES ]; then
	    echo
	    echo "Error: incorrect machine file (-m $ORIG_MFILE) (max procs per node: $MAX_NUMA_NODES)"
	    echo
	    clean_exit
	    exit 1
	fi
    else
	j=0
    fi

    if [ $SET_NUMA -eq 1 ]; then
	cmd="/bin/sh -c 'export GASPI_MASTER=$master_node;export GASPI_SOCKET=$j;export GASPI_TYP=$TYP;export GASPI_MFILE=$MFILE;export GASPI_SET_NUMA_SOCKET=1; if [ -x $KPRG ]; then $PRG; else echo '$i': '$KPRG' not found;exit 1;fi 2> /dev/null &'"
    else
	cmd="/bin/sh -c 'export GASPI_MASTER=$master_node;export GASPI_SOCKET=$j;export GASPI_TYP=$TYP;export GASPI_MFILE=$MFILE; if [ -x $KPRG ]; then $PRG;else echo '$i': '$KPRG' not found;exit 1;fi 2> /dev/null &'"
    fi

    ssh $i $cmd  >> $RUN_FILE &

    previous="$i"

done < $MFILE

PRGNAME=`basename $KPRG`
echo $PRGNAME  > /tmp/.last_gaspi_prg
if [ -O /tmp/.last_gaspi_prg ]; then
    chmod a+rw /tmp/.last_gaspi_prg &> /dev/null
fi

#check all started well
sleep 1
grep "${KPRG} not found" $RUN_FILE
if [ $? = 0 ]; then
    echo "Error: Failed to start $PRG on remote nodes"
    echo
    cat $RUN_FILE
    echo
    clean_exit
    exit 1
fi

#start master
t1=$(date +%s)
tdiff=$(( $t1 - $t0 ))
echo ssh-startup time: $tdiff sec

if [ "$master_node" != "$HN" ]; then
    if [ $DEBUG != 0 ]; then
	echo
	echo "Running with debugger only allowed if current node ($HN) is the first node in machinefile"
	echo
	clean_exit
	exit 1
    fi
    #prepare differently for remote node
    chmod a+r $MFILE &> /dev/null
    TMP_FILE=`readlink -f $MFILE`
    MFILE=$TMP_FILE
    scp $MFILE ${master_node}:${MFILE} &> /dev/null
    if [ $? != 0 ]; then
	echo "Warning: Failed to copy machinefile to remote host. Program might not start correctly."
    fi

    if [ $SET_NUMA -eq 1 ]; then
 	cmd="/bin/sh -c 'export GASPI_MASTER=$master_node;export GASPI_SOCKET=0;export GASPI_TYP=GASPI_MASTER;export GASPI_MFILE=$MFILE;export GASPI_SET_NUMA_SOCKET=1; $MASTER_PRG'"
    else
 	cmd="/bin/sh -c 'export GASPI_MASTER=$master_node;export GASPI_SOCKET=0;export GASPI_TYP=GASPI_MASTER;export GASPI_MFILE=$MFILE; $MASTER_PRG'"
     fi
    ssh $master_node $cmd
    if [ $? != 0 ]; then
	echo "Error: Failed to start $MASTER_PRG on $master_node"
	clean_exit
	exit 1
    fi
else
    export GASPI_MASTER=$HN;

    if [ $SET_NUMA -eq 1 ]; then
	export GASPI_SET_NUMA_SOCKET=1;
    fi
    export GASPI_SOCKET=0;
    export GASPI_TYP=GASPI_MASTER;
    export GASPI_MFILE=$MFILE;


    if [ $DEBUG != 0 ]; then
	gdb --args $MASTER_PRG
    else
	$MASTER_PRG
    fi
    if [ $? != 0 ]; then
	clean_exit
	exit 1
    fi
fi

#clean-up and exit
clean_exit

exit 0
